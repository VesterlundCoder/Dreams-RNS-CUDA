#!/usr/bin/env python3
"""
Odd-Zeta CMF Sweep: explore ζ(2n+1) CMFs with shifts × depth, check all constants.

Loads CMF specs generated by odd_zeta_cmf_generator.py, compiles each 2n×2n
matrix, walks with many shifts, and checks convergent against all constants
(including ζ(3)..ζ(21), π variants, Catalan, etc.).

The walk variable is k (single axis). Each shift gives a different starting
point k₀, and the walk computes M(k₀)·M(k₀+1)·...·M(k₀+depth).
The accumulator row accumulates the partial sum → should approach ζ(2n+1).

Usage:
    # Generate specs first
    python odd_zeta_cmf_generator.py --n-min 2 --n-max 10 --output odd_zeta_specs.jsonl

    # Sweep all with 512 shifts, depth=2000
    python odd_zeta_sweep.py --specs odd_zeta_specs.jsonl --depth 2000 --shifts 512

    # Quick test: just ζ(5) with 10 shifts
    python odd_zeta_sweep.py --specs odd_zeta_specs.jsonl --depth 500 --shifts 10 --max-cmfs 1
"""

import argparse
import csv
import json
import math
import os
import sys
import time
from pathlib import Path
from typing import List, Dict, Any

import numpy as np

sys.path.insert(0, str(Path(__file__).resolve().parent))

from dreams_rns.compiler import CmfCompiler, compile_cmf_from_dict
from dreams_rns.runner import generate_rns_primes
from dreams_rns import crt_reconstruct, centered
from dreams_rns.constants import load_constants, match_against_constants, compute_delta_against_constant

import sympy as sp
import mpmath as mp


def compile_odd_zeta_cmf(spec: Dict) -> Any:
    """Compile an odd-zeta CMF spec into a CmfProgram."""
    matrix_dict = {}
    for key, expr_str in spec['matrix'].items():
        r, c = key.split(',')
        matrix_dict[(int(r), int(c))] = expr_str

    program = compile_cmf_from_dict(
        matrix_dict=matrix_dict,
        m=spec['rank'],
        dim=spec['dim'],
        axis_names=spec.get('axis_names', ['k']),
        directions=spec.get('directions', [1]),
    )
    return program


def estimate_K_for_cmf(rank: int, depth: int) -> int:
    """Estimate K primes for a rank×rank CMF at given depth."""
    if depth > 1:
        log2_fact = depth * math.log2(depth / math.e) + 0.5 * math.log2(2 * math.pi * depth)
    else:
        log2_fact = 1
    bits_needed = int(rank * log2_fact * 1.5) + 200
    K = max(bits_needed // 31 + 1, 64)
    return K


def compute_initial_state(n: int):
    """Compute initial state v(1) for ζ(2n+1) in exact rationals.

    v = [U0(1), 0, ..., 0, S(1), 1, 0, ..., 0]
    where U0(1) = A_1 = 1/2, S(1) = T_n(1).
    """
    from fractions import Fraction

    d = 2 * n

    # A_k = (-1)^(k-1) / C(2k, k)
    def A_k(k):
        from math import comb
        return Fraction((-1)**(k-1), comb(2*k, k))

    # Elementary symmetric polynomials e_0..e_{n-1} for x_m = 1/m², m=1..k-1
    def e_list(k_minus_1, nn):
        e = [Fraction(0)] * nn
        e[0] = Fraction(1)
        for m in range(1, k_minus_1 + 1):
            xm = Fraction(1, m**2)
            for j in reversed(range(1, nn)):
                e[j] = e[j] + xm * e[j-1]
        return e

    # Kernel coefficients c_{n,j}(k)
    def kernel_coeffs(k, nn):
        coeffs = [Fraction(0)] * nn
        coeffs[nn-1] += Fraction(5) * Fraction((-1)**(nn-1))
        for j in range(0, nn-1):
            t = (nn-1) - j
            coeffs[j] += Fraction(4) * Fraction((-1)**j) / Fraction(k**(2*t))
        return coeffs

    # T_n(k) = (1/2) * A_k / k³ * Σ_j c_{n,j}(k) * e_j^{(k-1)}
    def direct_term(k, nn):
        Ak = A_k(k)
        e = e_list(k-1, nn)
        c = kernel_coeffs(k, nn)
        s = sum(c[j] * e[j] for j in range(nn))
        return Fraction(1, 2) * Ak * s / Fraction(k**3)

    v = [Fraction(0)] * d
    v[0] = Fraction(1, 2)           # U0(1) = A_1 = 1/2
    v[n] = direct_term(1, n)        # S(1) = T_n(1)
    v[n+1] = Fraction(1)            # constant = 1
    return v


def run_odd_zeta_walk(program, depth: int, K: int, shift: int, n: int):
    """State-vector walk for odd-zeta CMF: v(k+1) = M(k) · v(k).

    This is LEFT multiplication (SageMath convention), not the standard
    PCF right-multiplication P = M(1)·M(2)·...·M(N).

    Args:
        program: compiled CmfProgram
        depth: walk depth
        K: number of RNS primes
        shift: starting value of k (usually 1)
        n: the n in ζ(2n+1) (for initial state)

    Returns:
        dict with acc_residues, const_residues, acc_float, log_scale, primes
    """
    from dreams_rns.cmf_walk import (
        _eval_bytecode_allprimes_multiaxis,
        _eval_bytecode_float_multiaxis,
        _precompute_const_residues,
    )

    r = program.m
    pp = generate_rns_primes(K).astype(np.int64)
    const_table = _precompute_const_residues(program, pp)

    # Initial state as rationals → convert to RNS residues
    v0_frac = compute_initial_state(n)

    # RNS state vector: v_rns[i, k] = v[i] mod prime_k
    v_rns = np.zeros((r, K), dtype=np.int64)
    for i in range(r):
        num = v0_frac[i].numerator
        den = v0_frac[i].denominator
        for ki in range(K):
            p = int(pp[ki])
            num_mod = num % p
            den_mod = den % p
            den_inv = pow(den_mod, p - 2, p) if den_mod != 0 else 0
            v_rns[i, ki] = (num_mod * den_inv) % p

    # Float state vector
    v_f = np.array([float(f) for f in v0_frac], dtype=np.float64)
    log_scale = 0.0

    shift_vals = [shift]

    # Track denominator growth analytically
    # For HPHP08 CMF at axis value v = shift + step:
    #   Key denominators: 2*(2v+1), v², (v+1)^(2n+1)
    log_denom = 0.0

    for step in range(depth):
        v_val = shift + step  # axis value at this step

        # Estimate denominator contribution from M(step)
        # rk = -(v+1)/(2*(2v+1)) → denom factor: 2*(2v+1)
        # rk/v² → extra factor: v²
        # accumulator: (1/2)/(v+1)³ and 1/(v+1)^(2t) → factor: 2*(v+1)^(2n+1)
        if v_val > 0:
            log_denom += math.log(2*(2*v_val+1))
            log_denom += 2*math.log(max(v_val, 1))
            log_denom += (2*n+1) * math.log(v_val + 1)
            log_denom += math.log(2)

        # Evaluate M(step) for all primes and float
        M_rns = _eval_bytecode_allprimes_multiaxis(
            program, step, shift_vals, pp, const_table)  # (r, r, K)
        M_f = _eval_bytecode_float_multiaxis(program, step, shift_vals)  # (r, r)

        # v = M · v (LEFT multiply, state vector)
        new_v_rns = np.zeros_like(v_rns)
        for i in range(r):
            for j in range(r):
                new_v_rns[i] = (new_v_rns[i] + M_rns[i, j] * v_rns[j]) % pp
        v_rns = new_v_rns

        new_v_f = M_f @ v_f
        v_f = new_v_f

        # Normalize float shadow
        mx = np.max(np.abs(v_f))
        if mx > 1e10:
            v_f /= mx
            log_scale += math.log(mx)

    # Extract accumulator (index n) and constant (index n+1)
    acc_idx = n
    const_idx = n + 1

    return {
        'acc_residues': v_rns[acc_idx],
        'const_residues': v_rns[const_idx],
        'acc_float': v_f[acc_idx],
        'const_float': v_f[const_idx],
        'log_scale': log_scale,
        'log_denom': log_denom,
        'primes': pp,
    }


def main():
    parser = argparse.ArgumentParser(
        description="Odd-Zeta CMF Sweep: explore ζ(2n+1) with shifts"
    )
    parser.add_argument("--specs", type=str, required=True,
                        help="CMF specs JSONL from odd_zeta_cmf_generator.py")
    parser.add_argument("--depth", type=int, default=2000,
                        help="Walk depth")
    parser.add_argument("--shifts", type=int, default=512,
                        help="Number of shifts (k starts at 1, 2, ..., shifts)")
    parser.add_argument("--K", type=int, default=0,
                        help="RNS primes (0=auto per CMF)")
    parser.add_argument("--dps", type=int, default=200,
                        help="mpmath decimal precision")
    parser.add_argument("--max-cmfs", type=int, default=0,
                        help="Max CMFs to process (0=all)")
    parser.add_argument("--output", type=str, default="odd_zeta_results/",
                        help="Output directory")
    args = parser.parse_args()

    # Load constants (extended with ζ(9)..ζ(21))
    constants = load_constants(args.dps)
    print(f"Constants bank: {len(constants)} constants")
    for c in constants:
        print(f"  {c['name']:<15} = {c['value_float']:.15f}  ({c['description']})")

    # Load CMF specs
    specs = []
    with open(args.specs) as f:
        for line in f:
            line = line.strip()
            if line:
                specs.append(json.loads(line))

    if args.max_cmfs > 0:
        specs = specs[:args.max_cmfs]

    print(f"\nOdd-Zeta CMF Sweep")
    print(f"  CMFs:    {len(specs)}")
    print(f"  Shifts:  {args.shifts}")
    print(f"  Depth:   {args.depth}")
    print(f"  K:       {'auto' if args.K == 0 else args.K}")
    print(f"{'='*80}")

    os.makedirs(args.output, exist_ok=True)

    # Results file
    results_path = os.path.join(args.output, "odd_zeta_results.jsonl")
    summary_path = os.path.join(args.output, "odd_zeta_summary.csv")

    all_results = []

    for ci, spec in enumerate(specs):
        name = spec['name']
        zeta_val = spec['zeta_val']
        rank = spec['rank']
        n = spec['n']
        acc_idx = spec.get('accumulator_idx', n)
        const_idx = spec.get('constant_idx', n + 1)

        print(f"\n{'─'*80}")
        print(f"[{ci+1}/{len(specs)}] {name}: ζ({zeta_val}), {rank}×{rank} matrix")

        # Compile
        t0 = time.time()
        try:
            program = compile_odd_zeta_cmf(spec)
        except Exception as e:
            print(f"  COMPILE ERROR: {e}")
            continue

        # Auto-K
        if args.K > 0:
            K_use = args.K
        else:
            K_use = estimate_K_for_cmf(rank, args.depth)
        print(f"  K={K_use} ({K_use*31} bits CRT range)")

        compile_time = time.time() - t0

        # Walk with each shift
        cmf_results = []
        best_hit = None

        for si in range(1, args.shifts + 1):
            try:
                res = run_odd_zeta_walk(program, args.depth, K_use, shift=si, n=n)

                # CRT reconstruction of accumulator and constant
                primes = [int(p) for p in res['primes']]
                acc_big, Mp = crt_reconstruct(
                    [int(r) for r in res['acc_residues']], primes)
                const_big, _ = crt_reconstruct(
                    [int(r) for r in res['const_residues']], primes)
                acc_big = centered(acc_big, Mp)
                const_big = centered(const_big, Mp)

                # Float estimate: accumulator / constant
                acc_f = res['acc_float']
                const_f = res['const_float']
                est = acc_f / const_f if abs(const_f) > 1e-300 else float('nan')
                log_scale = res['log_scale']

                if not math.isfinite(est):
                    continue

                # CRT overflow check
                mp.mp.dps = args.dps
                crt_ok = True
                if const_big == 0:
                    crt_ok = False
                else:
                    try:
                        cr = float(mp.mpf(acc_big) / mp.mpf(const_big))
                        if not math.isfinite(cr):
                            crt_ok = False
                        elif abs(est) > 1e-10:
                            crt_ok = abs(cr - est) / abs(est) < 0.01
                        else:
                            crt_ok = abs(cr - est) < 0.01
                    except Exception:
                        crt_ok = False

                # Check all constants using float delta with analytical denominator
                best_delta = float('-inf')
                best_const = None
                log_denom = res['log_denom']

                for c in constants:
                    try:
                        err = abs(est - c['value_float'])
                        if err > 0 and log_denom > 0:
                            delta = -(1.0 + math.log(err) / log_denom)
                        elif err == 0:
                            delta = float('inf')
                        else:
                            delta = float('-inf')
                    except Exception:
                        delta = float('-inf')

                    if delta > best_delta:
                        best_delta = delta
                        best_const = c['name']

                result = {
                    'cmf': name,
                    'zeta_val': zeta_val,
                    'rank': rank,
                    'shift': si,
                    'est': est,
                    'best_const': best_const,
                    'best_delta': best_delta,
                    'crt_ok': crt_ok,
                    'p_bits': Mp.bit_length(),
                }

                cmf_results.append(result)

                if best_delta > (best_hit['best_delta'] if best_hit else float('-inf')):
                    best_hit = result

            except Exception as e:
                if si == 1:
                    print(f"  WALK ERROR (shift={si}): {e}")
                    import traceback; traceback.print_exc()
                continue

        elapsed = time.time() - t0

        # Report
        n_positive = sum(1 for r in cmf_results if r['best_delta'] > 0)
        n_valid = len(cmf_results)

        if best_hit:
            print(f"  {n_valid}/{args.shifts} walks OK, {n_positive} with δ>0")
            print(f"  Best: δ={best_hit['best_delta']:.6f} → {best_hit['best_const']} "
                  f"(shift={best_hit['shift']}, est={best_hit['est']:.10f})")
        else:
            print(f"  No valid results")

        print(f"  ({elapsed:.1f}s, {n_valid/elapsed:.0f} walks/s)" if elapsed > 0 else "")

        # Save per-CMF results
        all_results.extend(cmf_results)

    # Write all results
    with open(results_path, 'w') as f:
        for r in all_results:
            f.write(json.dumps(r, default=str) + "\n")

    # Write summary CSV
    if all_results:
        summary_rows = []
        for spec in specs:
            name = spec['name']
            zv = spec['zeta_val']
            rk = spec['rank']
            cmf_res = [r for r in all_results if r['cmf'] == name]
            if cmf_res:
                best = max(cmf_res, key=lambda x: x['best_delta'])
                n_pos = sum(1 for r in cmf_res if r['best_delta'] > 0)
                summary_rows.append({
                    'cmf': name,
                    'zeta': zv,
                    'rank': rk,
                    'n_shifts': len(cmf_res),
                    'n_positive_delta': n_pos,
                    'best_delta': f"{best['best_delta']:.6f}",
                    'best_const': best['best_const'],
                    'best_shift': best['shift'],
                    'best_est': f"{best['est']:.12f}",
                })

        with open(summary_path, 'w', newline='') as f:
            writer = csv.DictWriter(f, fieldnames=summary_rows[0].keys())
            writer.writeheader()
            writer.writerows(summary_rows)

    print(f"\n{'='*80}")
    print(f"RESULTS")
    print(f"  Total walks: {len(all_results)}")
    print(f"  δ>0 hits:    {sum(1 for r in all_results if r['best_delta'] > 0)}")
    print(f"  Results:     {results_path}")
    print(f"  Summary:     {summary_path}")


if __name__ == "__main__":
    main()
